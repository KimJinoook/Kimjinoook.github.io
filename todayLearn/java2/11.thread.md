# 프로세스와 쓰레드
## 1. 쓰레드란
- 할당된 메모리공간을 기반으로 실행중에 있는 프로그램
- 프로그램을 실행하면 os로부터 메모리를 할당받아 프로세스가 된다
- 프로그램을 수행하는데 필요한 데이터와 메모리등의 자원과 쓰레드로 구성
- 쓰레드
  - 프로세스 내에서 실제로 작업을 수행
  - 별도의 실행흐름
  - 모든 프로세스에는 최소 하나 이상의 쓰레드가 존재
  - 둘 이상의 쓰레드를 가진 프로세스 : 멀티쓰레드 프로세스
- 멀티 태스킹
  - 여러 개의 프로세스가 동시에 실행되는 것처럼 보이는 것
- 멀티 쓰레딩
  - 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업 수행
- 싱글 쓰레드
  - 실행 흐름이 하나밖에 없으므로 한번에 하나의 작업밖에 하지 못한다
- 멀티 쓰레드
  - 하나의 응용프로그램에 두개 이상의 쓰레드가 동시에 실행될 수 있다
  - 두개의 작업을 병렬적으로 처리
  - 계산작업, 스풀링 등
  - 장점
    - CPU 사용률 향상
    - 자원사용 효율성
    - 사용자에 대한 응답성 향상
    - 작업이 분리되어 코드가 간결
  - 단점
    - 여러 쓰레드가 같은 프로세스 내에서 자원 공유
      - 동기화, 교착상태 문제 고려
      - (두 쓰레드가 같은 자원을 사용하려 기다리느라 진행이 멈춘 상태)   

```java
public class ThreadMain {

	public static void main(String[] args) {
		System.out.println("main메서드");
		Thread th = Thread.currentThread(); //현재 실행중인 쓰레드의 참조를 반환
		System.out.println("현재 실행중인 스레드 : "+ th.getName()); //쓰레드의 이름을 반환
		
		int cnt = Thread.activeCount();
		System.out.println("실행중인 스레드 개수 : "+ cnt);
		
		Thread.currentThread().setName("Prime");
		System.out.println("변경된 스레드 이름 : "+Thread.currentThread().getName());

	}

}
/*
main메서드
현재 실행중인 스레드 : main
실행중인 스레드 개수 : 1
변경된 스레드 이름 : Prime
*/
```
***

## 2. 쓰레드의 구현과 실행
- Thread클래스 상속   
```java
class ThreadTest extends Thread{
  public void run(){
    작업내용
  }
}
```   
> ThreadTest t = new ThreadTest();   
> t.start();


- Runnable 인터페이스 구현
  - 스레드 클레스가 상속해야할 또 다른 클래스가 존재하는 경우 사용   

```java
class ThreadTest implements Runnable{
  public void run(){
    작업내용
  }
}
```   
> ThreadTest r = new ThreadTest();   
> Thread t = new Thread(r);   
> t.start();   

```java
package com.thread.day1;

public class ThreadTest1 {

	public static void main(String[] args) {
		MyThread1 th1 = new MyThread1("상속스레드");
		MyRunnable1 r = new MyRunnable1();
		Thread th2 = new Thread(r);
		th2.setName("구현스레드");
		
		th1.start();
		th2.start();
		
		System.out.println("main스레드 종료");

	}

}

class MyThread1 extends Thread{
	MyThread1(String name){
		super(name);
	}

	public void run() {
		for (int i = 0; i<5 ; i++) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}


class MyRunnable1 implements Runnable{
	public void run() {
		for (int i = 0; i<5 ; i++) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}
/*
결과는 매번 달라지며 스레드의 우선순위가 같아 동시에 처리
*/
```

- run() 메서드 직접호출
	- 단순한 메서드 호출일 뿐, 쓰레드의 생성으로 이어지지 않는다
	- 쓰레드는 자신만의 메모리 공간을 할당받아 별도의 실행흐름을 형성
- start() 메서드
	- 메모리 공간의 할당 등 쓰레드의 실행 기반을 마련
	- run 메서드를 대힌 호출해준다   

***

## 3. 쓰레드의 메모리 구성
- 쓰레드 : 별도의 실행흐름 형성
	- main메서드와 다른 실행흐름을 형성하기 위해 별도의 스택이 할당되어야 한다   

![캡처](https://user-images.githubusercontent.com/99188096/163298347-5b48c11e-35d5-4565-b77b-8fc459bd2bc1.PNG)   

- **모든 쓰레드는 자신의 스택을 할당받는다**
- **힙과 메서드 영역은 모든 쓰레드가 공유한다**
- 힙 영역의 공유
	- 모든 쓰레드가 동일한 힙 영역 접근 가능
	- A쓰레드가 만든 인스턴스의 주소값을 알면 B쓰레드에서 접근 가능   

```java
package com.thread.day1;

import javax.swing.JOptionPane;

public class ThreadTest3 {

	public static void main(String[] args) {
		MyThread2 th = new MyThread2();
		th.start();
		
		String str = JOptionPane.showInputDialog("값 입력");
		System.out.println(str);

	}

}

class MyThread2 extends Thread{
	public void run() {
		for(int i=10 ; i>0;i--) {
			System.out.println(i);
			try {
				Thread.sleep(1000); //지정된 시간동안 쓰레드를 일시정지시킨다
				
			}catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
/*
값을 입력받는동안 MyThread의 for문은 계속 실행되고있다
*/
```
