# 데이터 정의어 / DDL + 테이블 제약조건
## 1. ddl
- 오라클
  - 데이터를 저장하고 관리해주는 프로그램
  - 관리를 위해 다양한 저장객체 (오브젝트)를 생성
- ddl
  - 오브젝트를 생성,변경,관리하는 명령어
- create
  - 새로운 오브젝트나 스키마를 생성
  - 데이터 베이스 객체들을 생성
  > create 객체종류 객체명..   

- drop
  - 객체들을 삭제할 때 사용
  - delete : 테이블 상의 데이터를 삭제
  - drop : 객체 자체를 데이터베이스에서 영구히 삭제
  > drop 객체종류 객체명..   

- alter
  - 기존 생성된 객체를 변경할 때 사용
  - 테이블 사용중 컬럼을 추가하는 등
  > alter 객체종류 객체명..   

- truncate
  - delete문과 동일한 역할
  - rollback으로 복구 불가 (자동 commit)
  - delete보다 수행속도가 빠르다
  - delete
    - 메모리 상에 존재하는 테이블의 데이터만 삭제
    - 디스크 상의 공간은 그대로 가지고 있다
  - truncate
    - 메모리,데이터파일의 데이터 삭제, 테이블 구조는 보존
    - 최초에 테이블이 만들어졌던 상태로  
  - drop
    - 테이블 구조까지 소멸
  > truncate table 테이블명...   


***

## 2. Create과 데이터타입
```sql
create table 테이블명
(
  컬럼1 데이터타입,
  컬럼2 데이터타입,
  ...
)
tablespace 테이블스페이스명;
```

- 테이블이름 : 최대 30byte
- 컬럼명,스키마,사용자이름 : 30byte
- 최대 255개의 컬럼
- 컬럼의 데이터 타입
  - 문자형 데이터
    - char : 고정길이의 문자형데이터, 최대 2000byte
    - varchar2 : 가변길이의 문자형데이터, 최대 4000byte
    - clob : 문자열이나 문서 저장가능, 최대 4gb까지 저장
  - 숫자형 데이터
    - number : 가변숫자타입, 21byte
  - 날짜형 데이터
    - date : 고정길이의 데이터, 7byte   

- 문자형데이터 확인  

```sql
create table char_exam1
(
    name1 char(3), --고정길이 3byte
    name2 varchar2(3) -- 가변길이 3byte
);


insert into char_exam1
values('AA','AA');

select name1, name2, length(name1), length(name2),
    replace(name1, ' ','*'), replace(name2,' ', '*') from char_exam1;
    
NAM NAM LENGTH(NAME1) LENGTH(NAME2) REP REP
--- --- ------------- ------------- --- ---
AA  AA              3             2 AA* AA
```

```sql
create table char_exam1
(
    name1 char(3), --생략하면 byte
    name2 varchar2(3),
    name3 char(6 byte),
    name4 char(6 char),
    name5 char(6), --6byte
    name6 clob --4gb까지 저장
);

insert into char_exam1(name1,name2,name3,name4,name5,name6)
values('AAA','가','ABCDEF','ABCDEFG','AB',null);  --error
--name4가 6개 문자만 입력 가능하므로 에러

insert into char_exam1(name1,name2,name3,name4,name5,name6)
values('AAA','가','ABCDEF','가나다라마바','가나',null);
--인코딩에 따라 한글 1글자는 2바이트나 3바이트
--UTF-8 : 한글 1글자가 3바이트

insert into char_exam1(name1,name2,name3,name4,name5,name6)
values('AAA','가','ABCDEF','가나다라마바','가나다',null); --error
--name5는 6바이트이므로 한글 2글자만 입력 가능

insert into char_exam1(name1,name3,name6)
values('ABC','ABCDEF','ABCdefg가나다 clob 연습!!');
```

- 숫자형 데이터 확인   

```sql
create table num_exam1
(
    n1 number,
    n2 number(9), --전체 9자리 수까지 표현 가능
    n3 number(9,2), --전체 9자리수중 소수이하 2자리까지 표현
                    -- 소수3째자리에서 반올림
    n4 number(9,1),
    n5 number(7), --전체 7자리 수 표현, 소수이하 자리수는 표현하지 않음
    n6 number(7,-2), --7자리 표현, 10의 자리에서 반올림
    n7 number(6), --전체 6자리수 표현
    n8 number(3,5) --1보다 작은 실수 표현, 소수이하 5자리중 0이 두개 붙는다
    
);


insert into num_exam1(n1,n2,n3,n4,n5,n6)
values(1234567.89, 1234567.89,1234567.89,1234567.89,1234567.89,1234567.89);

insert into num_exam1(n1,n2,n3,n4,n5,n6,n7)
values(1234567.89, 1234567.89,1234567.89,1234567.89,1234567.89,1234567.89,1234567.89);
--n7은 전체 자리수 6개만 가능, 7개를 입력해서 에러

insert into num_exam1(n8)
values(0.00123);

insert into num_exam1(n8)
values(0.01234);  --error

insert into num_exam1(n8)
values(0.0012);

insert into num_exam1(n8)
values(0.000123);

        N1         N2         N3         N4         N5         N6         N7         N8
---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------                    
1234567.89    1234568 1234567.89  1234567.9    1234568    1234600                      
                                                                                 .00123
                                                                                  .0012
                                                                                 .00012
```

- 날짜 데이터 확인   

```sql
create table date_exam1
(
    d1 date,
    d2 timestamp
);



insert into date_exam1
values(sysdate, systimestamp);

insert into date_exam1
values(sysdate, sysdate);

insert into date_exam1
values(systimestamp, systimestamp);

D1                D2                         
----------------- ---------------------------
22/03/25 10:53:52 22/03/25 10:53:52.748000000
22/03/25 10:53:54 22/03/25 10:53:54.000000000
22/03/25 10:53:55 22/03/25 10:53:55.757000000
```

***

## 3. 무결성 제약조건
- 데이터를 흠 없이 안정되게 지켜주기 위한 것
- 제대로된 데이터들이 올바르게 저장될 수 있도록 하기 위해 데이터베이스 측에서 제공하는 기능들 => 무결성 제약조건
- 무결성을 지키기 위해 제약조건들을 제공함
- 제약조건들은 테이블의 컬럼에 적용됨
- 실체 무결성
  - primary key가 대표적
  - 여러 데이터(레코드)들 중 유일하게 구분지어 줄 수 있는 것
- 영역 무결성
  - 특정한 범위의 값만 와야하는 것
  - 주민등록번호의 값으로 1,2,3,4,만 입력되어야 하는 것
- 참조 무결성
  - 기본키와 외래키의 관계
  - 사원테이블의 부서코드는 반드시 부서테이블에 존재해야함
- 무결성 제약 조건
  - null
  - unique
  - primary key
    - not null + unique
  - foreign key
  - check
  - default

### null
- 데이터가 없음을 의미
- 컬럼의 속성 중 하나로 해당 컬럼이 null을 허용할지 여부 지정
- 데이터 타입 다음에 명시
- 필수로 들어가야 할 데이터는 not null로 제약
- 디폴트값 : null   


```sql
create table null_exam1
(
    col1 char(3) not null,
    col2 char(3) null,
    col3 char(3)
);

insert into null_exam1(col1,col2)
values('AA','BB');

insert into null_exam1(col2, col3)
values('B2','C2');  
--col1은 not null이므로 값을 입력해야 함

insert into null_exam1(col1, col2, col3)
values('A2',null, '');  --null을 직접 입력하는 경우 : null, ''입력

insert into null_exam1(col1, col3)
values('A3',' ');  --' '은 null이 아님

insert into null_exam1(col1)
values('A4');


select * from null_exam1
where col3 is null;

COL COL COL
--- --- ---
AA  BB     
A2         
A4         

select * from null_exam1
where col3 is not null;

COL COL COL
--- --- ---
A3         
```

### Unique
- 테이블에 있는 데이터를 유일하게 식별하기 위한 조건
- 사원테이블의 사원번호
- 사원테이블의 이메일주소
- 중복 값이 허용되지 않게 함
- 복합 unique키 - 한개 이상의 컬럼으로 unique를 만드는 것
- null 허용 가능   

```sql
create table unique_exam1
(
    col1    varchar2(10)  unique not null,
    col2    varchar2(10)  unique null, --null 허용
    col3    varchar2(10)  not null,
    col4    varchar2(10)  not null,
    constraint unique_col unique(col3, col4) --outline 제약조건, unique 복합키
);


insert into unique_exam1
values('AA','BB','CC','DD');

insert into unique_exam1(col1,col3,col4)
values('AA','C1','D1'); 
--unique제약조건 위배, col1에 AA가 이미 있으므로 중복될 수 없다

insert into unique_exam1(col1,col3,col4)
values('A4','CC','DD'); --error: col3, col4는 복합키로 unique해야 하므로

insert into unique_exam1(col1,col3,col4)
values('A1','C1','C2');  --col2는 unique 이지만, null허용하므로 입력 가능

insert into unique_exam1
values('A2',null,'C2','D2');

insert into unique_exam1
values('A3','','C3','D3');

insert into unique_exam1
values('A4','','C3','d2');


select * from unique_exam1;

COL1       COL2       COL3       COL4      
---------- ---------- ---------- ----------
AA         BB         CC         DD        
A1                    C1         C2        
A2                    C2         D2        
A3                    C3         D3 
A4                    C3         D2
```


### Primary Key
- 유니크와 동일하게 테이블의 데이터들을 유일하게 식별
- 반드시 not null
  - not null + unique 인덱스
- 하나 이상 컬럼으로 구성 - 복합키 가능
- **테이블당 오직 1개만** 생성 가능
- 인라인 표기방식
  - emp


### 제약조건 조회
- user_constraints, user_cons_columns 뷰 이용   
- type
  - c : not null
  - u : unique   

```sql
select * from user_constraints
where table_name like '%EXAM%';

select * from user_cons_columns
where table_name like '%EXAM%';

select a.table_name, a.constraint_name, a.constraint_type,
    a.index_name, b.column_name, b.position
from user_constraints a join user_cons_columns b
on a.constraint_name = b.constraint_name
and a.table_name like '%EXAM%';
```
