[JAVA]

1. OOP(Object-Oriented Programming, 객체 지향 프로그래밍) 이란?
: OOP는 현실 세계를 프로그래밍으로 옮겨와 현실 세계의 사물들을 객체로 보고, 그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍하는 기법입니다.

2. OOP의 장단점은?
: 장점
코드에 대한 재사용이 용이하다. 유지보수에 용이하다.
객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽다.
클래스단위로 모듈화 시켜서 개발할 수 있으므로, 업부 분담 용이하다.
단점
처리속도가 상대적으로 느리다.
객체가 많으면 용량이 커질 수 있다.
설계 시 많은 시간과 노력이 필요하다.
객체가 상태를 갖기에, 변수가 존재하고 변수를 통해 객체가 예측할 수 없는 상태를 갖게되면, Application 내부에서 버그를 발생시킵니다.

3. OOP 특징은?
1) 추상화
: 공통의 속성이나 기능을 묶어 이름을 붙이는 것. 객체 지향적 관점에서 클래스를 정의하는 것
2) 캡슐화
: 정보 은닉 - 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것 [키워드: private]
: 필요한 정보와 행동을 묶음과 동시에 보여줘야 할 것과 숨겨야 할 것으로 구분지음.
3) 상속
: 상위 개념의 특징을 하위 개념이 물려 받음.
4) 다형성 (유연성, 재활용성, 유지보수)
: 하나의 객체가 여러 형태를 띈다라는 의미. 상속받은 자식클래스들이 기능이 각기 다르다.

4. 오버라이딩, 오버로딩?
: 컴파일타입 다형성 : 오버로딩
같은 이름의 메소드를 매개변수의 개수 또는 타입을 변경해 여러개 사용.기존에 없던 새로운 메서드를 정의하는 것이고,
메소드 이름 절약,같은기능 메소드 하나이름

런타입타입 다형성 : 오버라이딩
상속받은 부모 클래스 메소드를 재정의해 사용. 상속받은 메서드를 덮어쓴다.
상황에 맞게 메소드를 변경해야하는 경우 오버라이딩.

5. 자바의 특징은?
1) 운영체제에 독립적
: JVM (자바가상머신 - 시스템 메모리를 관리하면서 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경 제공)에 동작하기 때문에, 특정 운영체제에 종속 되지 않음
2) 객체 지향 언어
: 클래스와 객체를 사용하여 프로그램을 간결하게 구현 가능
: 프로그래밍 하기 위해 여러 언어적 지원을 하고 있음
: 캡슐화, 상속, 추상화, 다형성이 특징
3) 자동 메모리 관리 (Garbage Collection)
4) 네트워크와 분산환경 지원
5) 멀티쓰래드(동시사용가능) 지원
6) 동적 로딩(그때 그때 사용 가능) 지원
7) 오픈소스임
: OpenJDK가 오픈소스임

6. 클래스 VS 객체 VS 인스턴스
: Class [클래스] - 객체를 정의해 놓은 것, 객체를 생성하기 위해 사용됨
: Object [객체] - 실제로 존재하는 것, 사물 또는 개념
: Instance [인스턴스] - 객체랑 비슷, 객체는 인스턴스를 포함하고 있음
인스턴스화 - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 함 ex) Car a = new Car();
클래스로부터 만들어진 객체를 그 클래스의 인스턴스(객체) 라고 함

7. JDBC란?
: Java Data Base Connection의 약자
: JAVA언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미

8. ARRAY VS LIST
Array
선언시 배열 크기 지정이 필요하다. 예) String list = new String[7]
객체를 넣을 때 인덱스 번호를 정의해야 한다. 예) list.add('book')
다차원 저장이 가능하다 (Multidimensional).
선언시 메모리가 할당된다
기본 데이터 타입(Primitive Type), 오브젝트 할당 가능하다
접근이 빠르다 (인덱스 번호를 이용해 Random access를 하기 때문)
List
사이즈 지정을 하지 않아도 동적으로 변화한다.
그냥 넣어도 된다.
다차원 저장이 불가능하다.
오브젝트만 할당 가능하다
(* 기본 데이터 타입도 할당 가능한 것처럼 보이지만 실제로는 JVM에 의해 오브젝트와 되어 할당되는 것이다. 따라서 기본 데이터 타입만 들어가는 자료구조가 요구될 때에는 Array가 Arraylist보다 더 효율적이다.)
추가, 삭제가 빠르다 (포인터로 Sequential access를 하기 때문)

9. MAP VS Set VS LIST
:List는 순서가 있는 데이터의 집합으로, 중복을 허용한다.
Set은 순서가 없는 데이터의 집합으로, 중복을 허용하지 않는다.
Map은 key와 value한 쌍으로 이루어지는 데이터의 집합으로 순서가 없다. 이 때 키는 중복을 허용하지 않는다.

List와 Set은 Collection 인터페이스를 상속받고 Map은 구조상의 차이로 인해 별도로 정의한다.

10. 33. Queue와 Stack의 차이는?
Queue는 선형자료구조의 일종으로 FIFO(First In, First Out)구조를 가지고 있고, Stack은 LIFO(Last In, First Out)구조를 가지고 있다.



[Spring]

1. 스프링 프레임워크란?
: 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크
: 동적인 웹 사이트 개발하기 위한 여러 가지 서비스를 제공함
: 대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자정부 표준프레임워크의 기반 기술.

2. 스프링프레임워크의 특징은?
DI (Dependency Injection) 의존성 주입
: 설정 파일이나 어노테이션을 통해 객체간의 의존 관계를 설정하여 개발자가 직접 의존하는 객체를 생성할 필요없음
Spring AOP(Aspect Oriented Programming) 관점 지향 프로그래밍
: 트랜잭션, 로깅, 보안 등 여러 모듈, 여러 계층에서 공통으로 필요로 하는 기능의 경우 해당 기능을 분리해 관리.
POJO(Plain Old Java Object)
: 일반적인 J2EE 프레임워크에 비해 특정 라이브러리를 사용할 필요가 없어 개발이 쉬움
: 기존 라이브러리의 지원이 용이
IOC(Inversion of Control) 제어 반전
: 컨트롤의 제어권이 개발자가 아니라 프레임워크에 있다는 뜻.
: 객체의 생성부터 모든 생명주기의 관리까지 프레임워크가 주도하고 있음.
: 객체를 생성하고, 직접 호출하는 프로그램이 아니라, 만들어둔 자원을 호출해서 사용.

3.Spring AOP가 무엇인지 OOP와 AOP를 비교하여 설명하시오.
: AOP는 Aspect Oriented Programming의 약자로, 관점 지향 프로그래밍이라고 합니다. 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법입니다. OOP는 Object Oriented Programming의 약자로 객체 지향 프로그래밍이라고 합니다. OOP와 AOP는 서로 상반되는 개념은 아니며 오히려 OOP를 더욱 OOP답게 사용할 수 있도록 하는 것이 AOP입니다.

공통적 기능을 모든 모듈에 적용하기 위한 방법으로 상속을 이용하는데 Java에서는 다중 상속이 불가능합니다. 그리고 기능 구현 부분에서 핵심 코드와 공통 기능 코드가 섞여있어서 보기에도 불편하고, 효율성이 떨어집니다. 이러한 이유로 AOP가 등장했습니다.

4. Spring MVC
: 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법

Model - 논리적 데이터 기반 구조를 표현, 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않음 (data 처리와 접근을 담당)
View - 사용자 인터페이스 내의 구성요소들을 표현 (사용자에게 보여지는 화면)
Controller - Model과 View를 연결하고 있는 클래스를 대표 (Model과 View 내의 클래스들 간 정보교환)

5. WAS와 WS의 차이
: WAS(Web Application Server) : 비지니스 로직을 넣을 수 있음 (Tomcat, PHP, ASP, Net 등)
WS(Web Server) : 비지니스 로직을 넣을 수 없음 (Nginx, Apache 등)

6. Spring 동작방식이란?
1. DispatcherServlet이 브라우저로부터 요청을 받는다.
2. DispatcherServlet은 요청된 URL을 HandlerMapping 객체에 넘기고,
호출해야 할 Controller 메소드(핸들러) 정보를 얻는다. 
3. DispatcherServlet이 HandlerAdapter 객체를 가져온다. 
4. HandlerAdapter 객체의 메소드를 실행한다.  
5. Controller 객체는 비즈니스 로직을 처리하고, 그 결과를 바탕으로 뷰(ex. JSP)에 전달할 객체를 Model 객체에 저장한다. DispatcherServlet에게 view name을 리턴한다.
6. DispatcherServlet은 view name을 View Resolver에게 전달하여 View 객체를 얻는다.
7. DispatcherServlet은 View 객체에 화면 표시를 의뢰한다.
8. View 객체는 해당하는 뷰(ex. JSP, Thymeleaf)를 호출하며, 뷰는 Model 객체에서 화면 표시에 필요한 객체를 가져와 화면 표시를 처리한다.

7. model1과 model2 패턴의 차이를 설명하라.
: model1은 뷰와 로직을 모두 JSP페이지 하나에서 처리하는 구조를 말하며
model2는 JSP페이지와 서블릿, 그리고 로직을 위한 클래스가 나뉘어 브라우저 요청을 한다.

8. Servlet vs JSP
Servlet
: 자바 언어로 웹 개발을 위해 만들어진 것
: Container가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것

JSP
: html기반에 JAVA코드를 블록화하여 삽입한 것
: Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

9. JSTL은 무엇이고 사용하는 이유는 무엇인가?
: JSP 표준 태그 라이브러리의 약어로써, 자신만의 태그를 추가할 수 있는 기능을 제공한다.
주로 JSTL의 core에서 c를 사용하여 <c:if> <c:forEach> 등으로 사용한다.

10. json VS xml
json
: JSON은 경량(Lightweight)의 DATA-교환 형식, 데이터를 저장하고 전달하는 메타언어입니다.
: Javascript에서 객체를 만들 때 사용하는 표현식을 의미한다.
장점 : JSON은 문자열을 전송받은 후에 해당 문자열을 바로 파싱하므로, XML보다 빠른 속도를 가지고 있습니다.
단점 : JSON은 개발자가 문자열 데이터의 무결성을 검증해야 합니다.

xml
: XML은 HTML과 매우 비슷한 문자 기반의 마크업 언어(text-based markup language)
장점 : 스키마를 사용하여 데이터의 무결성을 검증할 수 있습니다.
단점 : XML은 배열을 사용할 수 없고 (JSON은 배열 사용 가능), 데이터를 읽고 쓰는 것이 JSON 대비 느립니다.

11. 동기 VS 비동기식
: 동기식 - 요청과 결과가 동시에 이루어지는 것. 설계가 간단하지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하므로 비동기식 보다 비효율적이다.

: 비동기식 - 요청과 결과가 동시에 이루어지지 않는 것. 하나의 요청을 처리하는 동안 다른 요청도 처리가능. 동기보다 복잡하고 결과가 주어지는데 시간이 걸리더라도 그동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있음.

12. AJAX란? 장단점
: Ajax는 JavaScript의 라이브러리중 하나이며 Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자이다. 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법 이며 Ajax를 한마디로 정의하자면 JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술이라고 할 수 있겠습니다.

[특징]
전체 페이지를 갱신하지 않고 일부분만 업데이트 가능
사용자에게 즉각적인 반응과 풍부한 UI경험 제공 가능
ActiveX나 플러그인 프로그램 설치 없이 이용 가능
Javascript방식, jQuery방식으로 구현 가능

[단점]
JavaScript이므로 브라우저에 따른 크로스 브라우저 처리 필요
오픈 소스로 차별화가 어려움
연속적인 데이터 요청 시 서버 부하 증가하여 페이지가 느려짐
페이지 내 복잡도가 증가하여 에러 발생 시 디버깅이 어려움

13. JQuery란?
: 자바스크립트 라이브러리로 간단한 문법으로 ajax를 사용할 수 있음.

14. 스프링 VS 스프링 부트
: Embed Tomcat을 사용하기 때문에, (Spring Boot 내부에 Tomcat이 포함되어있다.) 따로 Tomcat을 설치하거나 매번 버전을 관리해 주어야 하는 수고로움을 덜어준다.

starter을 통한 dependency 자동화 :
아마 Spring 유저들이 가장 열광한 기능이 아닐까 싶다. 과거 Spring framework에서는 각각의 dependency들의 호환되는 버전을 일일이 맞추어 주어야 했고, 때문에 하나의 버전을 올리고자 하면 다른 dependeny에 까지 영향을 미쳐 version관리에 어려움이 많았다. 하지만, 이제 starter가 대부분의 dependency를 관리해주기 때문에 이러한 걱정을 많이 덜게 되었다.
XML설정을 하지 않아도 된다.
jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.
Spring Actuaor를 이용한 애플리케이션의 모니터링과 관리를 제공한다.

















[DB]

1. PK vs FK vs ER
Primary Key
: 테이블에서 각 Row(행)을 유일하게 구분하는 Column-Key

Foreign Key
: 하나의 테이블에 있는 Column(열)으로는 그 의미를 표현할 수 없는 경우,
다른 테이블의 Primary-Key Column의 값을 반드시 참조해야 하는 Key

ER(Entity-Relation)모델
: 개체-관계 모델, 데이터베이스를 설계할 때 사용하는 모델 중 하나

2. 참조 무결성
: 관계 데이터베이스 관계 모델에서 관련된 테이블 간의 일관성(데이터 무결성)을 말함
: 사용자의 실수로 관련 데이터가 삭제되거나 수정되는 것을 막아줌
: 참조 무결성 제약 조건

기본 테이블에서 일치하는 필드가 기본키(PK)이거나​고유 인덱스를 갖고 있거나 관련 필드의
데이터 형식이 같아야 함
​
3. DB Transaction(트랜잭션)
: 데이터의 무결성으로 인하여 데이터 작업시에 문제가 생기면, 데이터 작업을 하기 이전 시점으로 모든 데이터를 원상 복구 하는 것
: 모두 실행되거나 모두 실행되지 않거나를 뜻함

4. ACID 란? (트랜잭션의 성질)
Atomicity(원자성) : 모든 작업이 커밋되거나 롤백되는 특성
Consistency(일관성) : 데이터는 미리 정해진 특성에 의해서만 저장이 됨. 숫자 형태의 컬럼에 문자열이 들어올 수 없음.
Isolation(고립성) : 트랜잭션 수행 중에는 다른 트랜잭션의 영향을 주어서도 받아서도 안됨
Durability(지속성) : 트랜잭션 조작을 완료하고 그 조작이 영구적이 되어 결과를 잃어서는 안됨. 정상적인 상태 뿐만 아니라 장애가 난 상태에서도 결과를 잃어서는 안됨
DBMS VS RDBMS

5. Oracle VS MySQL
: 가장 큰 차이점으로는 비용이 있다. 오라클은 충분히 큰 예산과 복잡한 비즈니스 요구에 맞춰 기업고객들을 위해 설계되었다. MySQL은 가장 일반적으로 데이터베이스 기반 웹 사이트 및 Non-Critical 애플리케이션에 사용되는 저가의 데이터베이스 이다.

오라클은 유료인만큼 유용한 기능이 많다. 내장함수, 성능, 대용량 처리에 좋은 파티션 시스템, 힌트 대신 무겁다.

6. RDBMS VS DBMS
: 관계형DB
트랜잭션(전부 아니면 무): 전체 트랜잭션이 하나의 단위로 기록. 실패 시 전체 롤백
정규화: DB설계 시 중복을 최소화해서 구조화하는 프로세스

장점
데이터의 성능이 일반적으로 좋아 정렬, 탐색, 분류가 빠름. 신뢰성이 높아 데이터의 무결성을 보장. 정규화에 따른 갱신 비용을 최소화

단점
기존에 작성된 스키마를 수정하기 어려움
데이터베이스의 부하를 분석하기 어려움
빅데이터를 처리하는데 매우 비효율적임

: 비관계형 DB
거대한 Map으로서 key-value 형식을 지원함. 관계형 db와 달리 PK,FK JOIN등 관계를 정의하지 않음. 스키마에 대한 정의가 없다.

장점
대용량 데이터 처리를 하는데 효율적임. 읽기 작업보다 쓰기 작업이 더 빠르고 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 빠름. 데이터 모델링이 유연함. 뛰어난 확장성으로 검색에 유리함.
최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어남.
복잡한 데이터 구조를 표현할 수 있음.

단점
쿼리 처리시 데이터를 파싱 후 연산을 해야해서 큰 크기의 document를 다룰 때는 성능이 저하됨.

8. Mybatis
객체지향 언어인 자바의 관계형 DB 프로그래밍을 좀 더 쉽게 할 수 있게 도와주는 개발 프레임워크

9. COMMIT vs ROLLBACK
COMMIT
: 작성한 쿼리문에서 UPDATE, DELETE, INSERT를 수행했을 때, 그 쿼리문 수행결과에 대한 확정을 지음
ROLLBACK
: 쿼리문 수행결과에 대한 번복을 함
: 쿼리문 수행 이전으로 원상복귀 하겠다는 뜻
​
10. DML vs DDL vs DCL
DML
: 데이터베이스에 들어있는 데이터를 조작, 조회, 검색하기 위한 명령어 [ SELECT, DELETE, UPDATE, INSERT ]
DDL
: 테이블 구조를 정의하는데 사용되는 명령어 [CREATE, ALTER, DROP, TRUNCATE(초기화) ]
DCL
: 데이터베이스에 접근하거나 객체에 권한을 주는 등 역할을 하는 언어 [ COMMIT, ROLLBACK, GRANT, REVOKE ]

11. 트리거
: DML(데이터 조작어)가 수행됐을때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램.

12. JOIN( 2개 이상의 테이블에서 조건에 맞는 데이터를 추출하기 위하여 사용)
INNER JOIN
: 2개 이상의 테이블에서 교집합만을 추출
LEFT JOIN
: 2개 이상의 테이블에서 FROM에 해당하는 부분을 추출
RIGHT JOIN
: 2개 이상의 테이블에서 FROM과 JOIN하는 테이블에 해당하는 부분을 추출
OUTER JOIN
: 아웃터 조인 or 풀조인이라고 불림
: 2개 이상의 테이블에서 모든 테이블 해당하는 부분을 추출

13. 데이터베이스 장애
: 트랜잭션 장애 - 트랜잭션을 정상적으로 완료하지 못함
: 시스템 장애 - 하드웨어, 소프트웨어 고장으로 인한 장애
: 디스크 장애 - 디스크 스토리지 일부 or 전체 붕괴로 인한 장애

14. 이상현상
삽입이상 : 새 데이터 삽입을 위해 불필요한 데이터도 함께 삽입
갱신이상 : 일부 튜플만 변경
삭제이상 : 필요한 데이터까지 삭제되어 데이터 손실

15. INDEX
: 검색 속도를 높이기 위한 기술
: 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데 빠름.
: DML ( 데이터 조작어 ) 하는 경우에는 쿼리문 실행 속도가 느려짐.
즉, 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능.

사용하기 좋은 예) WHERE절에서 자주 사용되는 Column, 외래키가 자주 사용되는 Column,
JOIN에 자주 사용되는 Column,

피해야 하는 경우) Data중복도가 높은 Column,
DML이 자주 일어나는 Column.
